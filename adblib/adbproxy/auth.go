package adbproxy

import (
	"crypto"
	"crypto/rsa"
	"crypto/x509"
	"encoding/base64"
	"strings"
	"sync"
	"sync/atomic"
	"time"

	"github.com/pgaskin/go-adb/adb/adbproto/aproto"
)

// Authenticator authenticates connections. It should be safe to use
// concurrently.
type Authenticator interface {
	Auth(Auth) bool
}

// AuthFunc is a function implementing Authenticator.
type AuthFunc func(Auth) bool

func (fn AuthFunc) Auth(a Auth) bool {
	if fn == nil {
		return false
	}
	return fn(a)
}

// RateLimitAuthenticator delays by delay after the n'th failed auth request
// (starting at one). If n<= 0, it is set to 256. If delay<=0, it is set to 1s.
// These defaults match adb's behaviour.
func RateLimitAuthenticator(next Authenticator, n int, delay time.Duration) Authenticator {
	if n <= 0 {
		n = 256
	}
	if delay <= 0 {
		delay = time.Second
	}
	var count atomic.Uint32
	return AuthFunc(func(a Auth) bool {
		if next.Auth(a) {
			return true
		}
		if count.Add(1) > uint32(n) {
			time.Sleep(delay)
		}
		return false
	})
}

// Auth represents a piece of authentication material presented by a client.
type Auth interface {
	// PublicKey returns the public key and comment, if known.
	PublicKey() (*aproto.PublicKey, string)

	// Verify returns true if k validates.
	Verify(k *aproto.PublicKey) bool
}

var (
	_ Auth = (*AuthCertificate)(nil)
	_ Auth = (*AuthSignature)(nil)
)

// AuthCertificate represents a certificate presented by a client for TLS
// authentication as part of A_STLS.
type AuthCertificate struct {
	// Raw is the raw certificate as presented by the client.
	Raw []byte

	once sync.Once
	cert *x509.Certificate
	gkey *rsa.PublicKey
	pkey *aproto.PublicKey
}

func (s *AuthCertificate) parse() {
	if s.Raw == nil {
		return
	}

	cert, err := x509.ParseCertificate(s.Raw)
	if err != nil {
		return
	}
	s.cert = cert

	if gkey, ok := cert.PublicKey.(*rsa.PublicKey); ok {
		s.gkey = gkey
		if pkey, err := aproto.NewPublicKey(gkey); err == nil {
			s.pkey = pkey
		}
	}
}

func (s *AuthCertificate) PublicKey() (*aproto.PublicKey, string) {
	s.once.Do(s.parse)
	return s.pkey, ""
}

func (s *AuthCertificate) Verify(k *aproto.PublicKey) bool {
	s.once.Do(s.parse)
	if s.gkey == nil {
		return false
	}
	return aproto.GoPublicKey(k).Equal(s.gkey)
}

func (s *AuthCertificate) String() string {
	s.once.Do(s.parse)
	var b strings.Builder
	b.WriteString("A_STLS")
	if s.cert == nil {
		b.WriteString("<invalid>")
	} else {
		b.WriteString("[alg=")
		b.WriteString(s.cert.PublicKeyAlgorithm.String())
		b.WriteString(" sigalg=")
		b.WriteString(s.cert.SignatureAlgorithm.String())
		b.WriteString(" subject=")
		b.WriteString(s.cert.Subject.String())
		if s.pkey != nil {
			b.WriteString(" fingerprint=")
			b.WriteString(s.pkey.Fingerprint())
		}
		b.WriteString("]")
	}
	return b.String()
}

// AuthSignature represents a signature presented by a client for legacy
// authentication as part of A_AUTH. It usually only includes a public key if
// the initial attempt failed and it is a signature for the client's main adbkey
// (i.e., not vendor keys). If a public key is included, it has already been
// validated against the signature.
type AuthSignature struct {
	// AdbKey is the raw pubkey data, if known.
	AdbKey []byte
	// Token is the nonce generated by the server.
	Token [aproto.AuthTokenSize]byte
	// Signature is the signature from the client.
	Signature []byte

	once sync.Once
	gkey *rsa.PublicKey
	pkey *aproto.PublicKey
	name string
}

func (s *AuthSignature) parse() {
	if s.AdbKey == nil {
		return
	}

	pkey, name, err := aproto.ParsePublicKey(s.AdbKey)
	if err != nil {
		return
	}
	s.gkey = aproto.GoPublicKey(pkey)
	s.pkey = pkey
	s.name = name

	if !s.verifyInternal(s.pkey) {
		panic("adbkey must validate against token and signature if included")
	}
}

func (s *AuthSignature) PublicKey() (*aproto.PublicKey, string) {
	s.once.Do(s.parse)
	return s.pkey, s.name
}

func (s *AuthSignature) Verify(k *aproto.PublicKey) bool {
	s.once.Do(s.parse)
	return s.verifyInternal(k)
}

func (s *AuthSignature) verifyInternal(k *aproto.PublicKey) bool {
	return rsa.VerifyPKCS1v15(aproto.GoPublicKey(k), crypto.SHA1, s.Token[:], s.Signature) == nil
}

func (s *AuthSignature) String() string {
	s.once.Do(s.parse)
	var b strings.Builder
	b.WriteString("A_AUTH[token=")
	b.WriteString(base64.StdEncoding.EncodeToString(s.Token[:]))
	b.WriteString(" signature=")
	b.WriteString(base64.StdEncoding.EncodeToString(s.Signature))
	if s.pkey != nil {
		b.WriteString(" fingerprint=")
		b.WriteString(s.pkey.Fingerprint())
	}
	b.WriteString("]")
	return b.String()
}
